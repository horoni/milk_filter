/*
AI Slut
Generated by Qwen3-Coder
*/
use image::Rgb;
use rayon::prelude::*;

// Simulates quantization by reducing color precision across pixels in parallel
pub fn jpeg_quantization(img: &mut image::ImageBuffer<Rgb<u8>, Vec<u8>>, quality_factor: f32) {
    puffin::profile_function!();

    // Map quality_factor (0.0 - 1.0) to number of levels (e.g., 2 - 256)
    let num_levels_f32 = 2.0 + (254.0 * quality_factor.max(0.0).min(1.0));
    let mut num_levels = num_levels_f32 as u32;
    // Ensure at least 2 levels to avoid division by zero later, or handle 1 level separately
    if num_levels < 2 {
        num_levels = 2; // Or handle num_levels=1 case explicitly if needed
    }
    let num_levels_m1 = num_levels.saturating_sub(1); // N - 1

    // --- Create the LUT (Lookup Table) ---
    let mut lut = [0u8; 256];

    // Populate the LUT using the direct formula
    for input_val in 0..=255 {
        // Step 1: Map input (0-255) to a level index (0 to num_levels-1)
        // Formula: level_index = (input_val * num_levels) / 256 (integer division)
        let level_index = (input_val as u32 * num_levels) / 256;

        // Step 2: Map the level index (0 to num_levels-1) back to an output value (0-255)
        // Formula: output_val = (level_index * 255) / (num_levels - 1) (integer division)
        // To avoid division by zero if num_levels_m1 could be 0 (though we set min=2), we check:
        let output_val = if num_levels_m1 > 0 {
            (level_index * 255) / num_levels_m1
        } else {
            // This case should not occur if num_levels >= 2, but handle it
            if level_index > 0 { 255 } else { 0 }
        };

        lut[input_val as usize] = output_val.min(255) as u8; // Clamp just in case
    }

    // Handle the special case where num_levels was forced to 1 (or somehow is 1 despite the check)
    // Although our check above sets it to 2, if you want num_levels=1 to map everything to 128:
    // if num_levels_f32 < 2.0 { lut.fill(128); } // Put this before the loop if needed

    // --- Apply the LUT using rayon ---
    img.as_mut()
       .par_chunks_exact_mut(3)
       .for_each(|pixel_chunk| {
           pixel_chunk[0] = lut[pixel_chunk[0] as usize];
           pixel_chunk[1] = lut[pixel_chunk[1] as usize];
           pixel_chunk[2] = lut[pixel_chunk[2] as usize];
       });
}

// Simulates blockiness by averaging colors within blocks across rows in parallel
pub fn jpeg_blockiness(img: &mut image::ImageBuffer<Rgb<u8>, Vec<u8>>, block_size: u32) {
    puffin::profile_function!();

    let (width, _) = img.dimensions();
    let width = width as usize;
    let block_size = block_size as usize;

    let pixels = img.as_mut();

    pixels
        .par_chunks_exact_mut(width * 3) // Each chunk is a row of pixels (width * 3 bytes)
        .enumerate() // Get the row index (y)
        .for_each(|(_y, row_slice)| {
            // Pre-calculate the maximum x_start index to iterate up to
            let max_x_start = width.saturating_sub(1); // Ensure x_start + block_size doesn't go out of bounds initially

            for x_start in (0..=max_x_start).step_by(block_size) {
                // Calculate the actual block dimensions for this specific block, considering image boundaries
                let actual_block_width = block_size.min(width - x_start);
                // Note: block_height is always 1 when processing rows in parallel
                // let actual_block_height = block_size.min(height - y); // This is always 1 for a single row

                // --- Optimized Averaging Calculation ---
                // Iterate only within the *actual* block dimensions
                let mut sum_r = 0u32;
                let mut sum_g = 0u32;
                let mut sum_b = 0u32;
                let count = actual_block_width as u32; // Height is 1, so count is just the width

                // Calculate sum for the block
                // Start index within the *current row slice*
                let block_start_idx = x_start * 3;
                // End index (exclusive) within the *current row slice*
                let block_end_idx = (x_start + actual_block_width) * 3;

                // Iterate through the pixel bytes within the block range of this row
                for i in (block_start_idx..block_end_idx).step_by(3) {
                     sum_r += row_slice[i] as u32;
                     sum_g += row_slice[i + 1] as u32;
                     sum_b += row_slice[i + 2] as u32;
                }

                if count > 0 {
                    let avg_r = (sum_r / count) as u8;
                    let avg_g = (sum_g / count) as u8;
                    let avg_b = (sum_b / count) as u8;

                    // --- Optimized Averaging Application ---
                    // Apply the average color back to the block within this row slice
                    for i in (block_start_idx..block_end_idx).step_by(3) {
                        row_slice[i] = avg_r;
                        row_slice[i + 1] = avg_g;
                        row_slice[i + 2] = avg_b;
                    }
                }
            }
        });
}

// Example usage within your MilkImage process function:
// impl MilkImage {
//     pub fn process(&mut self) {
//         puffin::profile_function!();
//
//         let mut img = self.img.clone().unwrap(); // Still need a mutable copy
//
//         if self.conf.comp > 0 {
//             puffin::profile_scope!("simulate_compression");
//
//             let quality_factor = (100.0 - self.conf.comp as f32) / 100.0;
//             let block_size = ((self.conf.comp as f32 / 100.0) * 7.0).max(1.0) as u32;
//
//             // Apply simulation effects using rayon
//             simulate_jpeg_quantization(&mut img, quality_factor.max(0.05));
//             simulate_jpeg_blockiness(&mut img, block_size.min(8));
//         }
//         // ... rest of filter logic ...
//     }
// }
